{"version":3,"sources":["../../../../../src/api/rest/cache/FileSystemResponseCache.ts"],"sourcesContent":["import cacache from 'cacache';\nimport { Readable } from 'stream';\n\nimport type { ResponseCache, ResponseCacheEntry } from './ResponseCache';\n\ntype FileSystemResponseCacheInfo = ResponseCacheEntry['info'] & {\n  /** Stream integrity used to validate the local body response */\n  bodyIntegrity?: string;\n  /** If there is no response body */\n  empty?: boolean;\n  /** The expiration time, in seconds, when the response should be invalidated */\n  expiration?: number;\n};\n\nexport class FileSystemResponseCache implements ResponseCache {\n  /** The absolute path to the directory used to store responses */\n  private cacheDirectory: string;\n  /** Optional auto-expiration for all stored response */\n  private timeToLive?: number;\n\n  constructor(options: { cacheDirectory: string; ttl?: number }) {\n    this.cacheDirectory = options.cacheDirectory;\n    this.timeToLive = options.ttl;\n  }\n\n  /** Retrieve the cache response, if any */\n  async get(cacheKey: string): Promise<ResponseCacheEntry | undefined> {\n    const responseInfoKey = getResponseInfoKey(cacheKey);\n    const responseInfoMeta = await cacache.get.info(this.cacheDirectory, responseInfoKey);\n\n    // Abort if the response info is not found\n    if (!responseInfoMeta) {\n      return undefined;\n    }\n\n    const responseInfoBuffer = await cacache.get.byDigest(\n      this.cacheDirectory,\n      responseInfoMeta.integrity\n    );\n    const responseInfo: FileSystemResponseCacheInfo = JSON.parse(responseInfoBuffer.toString());\n\n    // Remove cache-specific data from the response info\n    const { empty, expiration, bodyIntegrity } = responseInfo;\n    delete responseInfo.empty;\n    delete responseInfo.expiration;\n    delete responseInfo.bodyIntegrity;\n\n    // Invalidate the response if it has expired, or there is no known body integrity\n    if (!bodyIntegrity || (expiration && expiration < Date.now())) {\n      return undefined;\n    }\n\n    // Create a read-stream for the response body\n    const responseBody = empty\n      ? Readable.from(Buffer.alloc(0))\n      : Readable.from(cacache.get.stream.byDigest(this.cacheDirectory, bodyIntegrity));\n\n    return {\n      body: Readable.toWeb(responseBody),\n      info: responseInfo,\n    };\n  }\n\n  /** Store the response for caching */\n  async set(\n    cacheKey: string,\n    response: ResponseCacheEntry\n  ): Promise<ResponseCacheEntry | undefined> {\n    const responseBodyKey = getResponseBodyKey(cacheKey);\n    const responseInfoKey = getResponseInfoKey(cacheKey);\n\n    // Create a copy of the response info, to add cache-specific data\n    const responseInfo: FileSystemResponseCacheInfo = { ...response.info };\n\n    // Add expiration time if the \"time to live\" is set\n    if (typeof this.timeToLive === 'number') {\n      responseInfo.expiration = Date.now() + this.timeToLive;\n    }\n\n    try {\n      // Store the response body as stream, and calculate the stream integrity\n      responseInfo.bodyIntegrity = await new Promise((fulfill, reject) => {\n        Readable.fromWeb(response.body)\n          .pipe(cacache.put.stream(this.cacheDirectory, responseBodyKey))\n          .on('integrity', (integrity) => fulfill(integrity))\n          .once('error', reject);\n      });\n    } catch (error: any) {\n      if (error.code !== 'ENODATA') {\n        throw error;\n      }\n\n      // Mark the response as empty\n      responseInfo.empty = true;\n      responseInfo.bodyIntegrity = undefined;\n    }\n\n    // Store the response info\n    const responseInfoBuffer = Buffer.from(JSON.stringify(responseInfo));\n    await cacache.put(this.cacheDirectory, responseInfoKey, responseInfoBuffer);\n\n    return await this.get(cacheKey);\n  }\n\n  /** Remove the response from caching */\n  async remove(cacheKey: string): Promise<void> {\n    await Promise.all([\n      cacache.rm.entry(this.cacheDirectory, getResponseBodyKey(cacheKey)),\n      cacache.rm.entry(this.cacheDirectory, getResponseBodyKey(cacheKey)),\n    ]);\n  }\n}\n\nfunction getResponseBodyKey(cacheKey: string) {\n  return `${cacheKey}UndiciBody`;\n}\n\nfunction getResponseInfoKey(cacheKey: string) {\n  return `${cacheKey}UndiciInfo`;\n}\n"],"names":["FileSystemResponseCache","constructor","options","cacheDirectory","timeToLive","ttl","get","cacheKey","responseInfoKey","getResponseInfoKey","responseInfoMeta","cacache","info","undefined","responseInfoBuffer","byDigest","integrity","responseInfo","JSON","parse","toString","empty","expiration","bodyIntegrity","Date","now","responseBody","Readable","from","Buffer","alloc","stream","body","toWeb","set","response","responseBodyKey","getResponseBodyKey","Promise","fulfill","reject","fromWeb","pipe","put","on","once","error","code","stringify","remove","all","rm","entry"],"mappings":"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"}