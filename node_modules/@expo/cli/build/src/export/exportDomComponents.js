"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    exportDomComponentAsync: ()=>exportDomComponentAsync,
    updateDomComponentAssetsForMD5Naming: ()=>updateDomComponentAssetsForMD5Naming
});
function _assert() {
    const data = /*#__PURE__*/ _interopRequireDefault(require("assert"));
    _assert = function() {
        return data;
    };
    return data;
}
function _crypto() {
    const data = /*#__PURE__*/ _interopRequireDefault(require("crypto"));
    _crypto = function() {
        return data;
    };
    return data;
}
function _path() {
    const data = /*#__PURE__*/ _interopRequireDefault(require("path"));
    _path = function() {
        return data;
    };
    return data;
}
function _resolveFrom() {
    const data = /*#__PURE__*/ _interopRequireDefault(require("resolve-from"));
    _resolveFrom = function() {
        return data;
    };
    return data;
}
function _url() {
    const data = /*#__PURE__*/ _interopRequireDefault(require("url"));
    _url = function() {
        return data;
    };
    return data;
}
const _saveAssets = require("./saveAssets");
const _serializeHtml = require("../start/server/metro/serializeHtml");
const _domComponentsMiddleware = require("../start/server/middleware/DomComponentsMiddleware");
const _env = require("../utils/env");
const _filePath = require("../utils/filePath");
function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
const debug = require("debug")("expo:export:exportDomComponents");
async function exportDomComponentAsync({ filePath , projectRoot , dev , devServer , isHermes , includeSourceMaps , exp , files  }) {
    var ref;
    const virtualEntry = (0, _filePath.toPosixPath)((0, _resolveFrom().default)(projectRoot, "expo/dom/entry.js"));
    debug("Bundle DOM Component:", filePath);
    // MUST MATCH THE BABEL PLUGIN!
    const hash = _crypto().default.createHash("sha1").update(filePath).digest("hex");
    const outputName = `${_domComponentsMiddleware.DOM_COMPONENTS_BUNDLE_DIR}/${hash}.html`;
    const generatedEntryPath = (0, _filePath.toPosixPath)(filePath.startsWith("file://") ? _url().default.fileURLToPath(filePath) : filePath);
    const baseUrl = `/${_domComponentsMiddleware.DOM_COMPONENTS_BUNDLE_DIR}`;
    // The relative import path will be used like URI so it must be POSIX.
    const relativeImport = "./" + _path().default.posix.relative(_path().default.dirname(virtualEntry), generatedEntryPath);
    // Run metro bundler and create the JS bundles/source maps.
    const bundle = await devServer.legacySinglePageExportBundleAsync({
        platform: "web",
        domRoot: encodeURI(relativeImport),
        splitChunks: !_env.env.EXPO_NO_BUNDLE_SPLITTING,
        mainModuleName: (0, _filePath.resolveRealEntryFilePath)(projectRoot, virtualEntry),
        mode: dev ? "development" : "production",
        engine: isHermes ? "hermes" : undefined,
        serializerIncludeMaps: includeSourceMaps,
        bytecode: false,
        reactCompiler: !!((ref = exp.experiments) == null ? void 0 : ref.reactCompiler),
        baseUrl: "./",
        // Minify may be false because it's skipped on native when Hermes is enabled, default to true.
        minify: true
    });
    const html = await (0, _serializeHtml.serializeHtmlWithAssets)({
        isExporting: true,
        resources: bundle.artifacts,
        template: (0, _domComponentsMiddleware.getDomComponentHtml)(),
        baseUrl: "./"
    });
    const serialAssets = bundle.artifacts.map((a)=>{
        return {
            ...a,
            filename: _path().default.join(baseUrl, a.filename)
        };
    });
    (0, _saveAssets.getFilesFromSerialAssets)(serialAssets, {
        includeSourceMaps,
        files,
        platform: "web"
    });
    files.set(outputName, {
        contents: html
    });
    return {
        bundle,
        htmlOutputName: outputName
    };
}
function updateDomComponentAssetsForMD5Naming({ domComponentReference , nativeBundle , domComponentBundle , files , htmlOutputName  }) {
    const assetsMetadata = [];
    for (const artifact of domComponentBundle.artifacts){
        if (artifact.type !== "js") {
            continue;
        }
        const artifactAssetName = `/${_domComponentsMiddleware.DOM_COMPONENTS_BUNDLE_DIR}/${artifact.filename}`;
        let source = artifact.source;
        // [0] Updates asset paths in the DOM component JS bundle (which is a web bundle)
        for (const asset of domComponentBundle.assets){
            const prefix = asset.httpServerLocation.startsWith("./") ? asset.httpServerLocation.slice(2) : asset.httpServerLocation;
            const uri = `${prefix}/${asset.name}.${asset.type}`;
            const regexp = new RegExp(`(uri:")(${uri})(")`, "g");
            const index = asset.scales.findIndex((s)=>s === 1) ?? 0; // DOM components (web) uses 1x assets
            const md5 = asset.fileHashes[index];
            source = source.replace(regexp, `$1${md5}.${asset.type}$3`);
            const domJsAssetEntity = files.get(artifactAssetName);
            (0, _assert().default)(domJsAssetEntity);
            domJsAssetEntity.contents = source;
        }
        // [1] Updates JS artifacts in HTML
        const md51 = _crypto().default.createHash("md5").update(source).digest("hex");
        const htmlAssetEntity = files.get(htmlOutputName);
        (0, _assert().default)(htmlAssetEntity);
        const regexp1 = new RegExp(`(<script src=")(.*${artifact.filename})(" defer></script>)`, "g");
        htmlAssetEntity.contents = htmlAssetEntity.contents.toString().replace(regexp1, `$1${md51}.js$3`);
        assetsMetadata.push({
            path: artifactAssetName.slice(1),
            ext: "js"
        });
    }
    // [2] Updates HTML names from native bundle
    const htmlContent = files.get(htmlOutputName);
    (0, _assert().default)(htmlContent);
    const htmlMd5 = _crypto().default.createHash("md5").update(htmlContent.contents.toString()).digest("hex");
    const hash = _crypto().default.createHash("sha1").update(domComponentReference).digest("hex");
    for (const artifact1 of nativeBundle.artifacts){
        if (artifact1.type !== "js") {
            continue;
        }
        const assetEntity = files.get(artifact1.filename);
        (0, _assert().default)(assetEntity);
        const regexp2 = new RegExp(`(['"])${hash}\\.html(['"])`, "g");
        assetEntity.contents = assetEntity.contents.toString().replace(regexp2, `$1${htmlMd5}.html$2`);
    }
    assetsMetadata.push({
        path: htmlOutputName,
        ext: "html"
    });
    return assetsMetadata;
}

//# sourceMappingURL=exportDomComponents.js.map