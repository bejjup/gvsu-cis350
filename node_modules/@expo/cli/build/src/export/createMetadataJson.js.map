{"version":3,"sources":["../../../src/export/createMetadataJson.ts"],"sourcesContent":["import path from 'path';\n\nimport type { BundleOutput } from './saveAssets';\n\nexport type BundlePlatform = 'android' | 'ios';\n\ntype PlatformMetadataAsset = { path: string; ext: string };\n\nexport type PlatformMetadata = { bundle: string; assets: PlatformMetadataAsset[] };\n\ntype FileMetadata = {\n  [key in BundlePlatform]: PlatformMetadata;\n};\n\nexport function createMetadataJson({\n  bundles,\n  fileNames,\n  embeddedHashSet,\n  domComponentAssetsMetadata,\n}: {\n  bundles: Partial<Record<BundlePlatform, Pick<BundleOutput, 'assets'>>>;\n  fileNames: Record<string, string[]>;\n  embeddedHashSet?: Set<string>;\n  domComponentAssetsMetadata?: Record<string, PlatformMetadataAsset[]>;\n}): {\n  version: 0;\n  bundler: 'metro';\n  fileMetadata: FileMetadata;\n} {\n  // Build metadata.json\n  return {\n    version: 0,\n    bundler: 'metro',\n    fileMetadata: Object.entries(bundles).reduce<Record<string, Partial<PlatformMetadata>>>(\n      (metadata, [platform, bundle]) => {\n        if (platform === 'web') return metadata;\n\n        // Collect all of the assets and convert them to the serial format.\n        const assets = bundle.assets\n          .filter((asset) => !embeddedHashSet || !embeddedHashSet.has(asset.hash))\n          .map((asset) =>\n            // Each asset has multiple hashes which we convert and then flatten.\n            asset.fileHashes?.map((hash) => ({\n              path: path.join('assets', hash),\n              ext: asset.type,\n            }))\n          )\n          .filter(Boolean)\n          .flat();\n\n        if (domComponentAssetsMetadata?.[platform] != null) {\n          assets.push(...domComponentAssetsMetadata?.[platform]);\n        }\n\n        return {\n          ...metadata,\n          [platform]: {\n            // Get the filename for each platform's bundle.\n            // TODO: Add multi-bundle support to EAS Update!!\n            bundle: fileNames[platform][0],\n            assets,\n          },\n        };\n      },\n      {}\n    ) as FileMetadata,\n  };\n}\n"],"names":["createMetadataJson","bundles","fileNames","embeddedHashSet","domComponentAssetsMetadata","version","bundler","fileMetadata","Object","entries","reduce","metadata","platform","bundle","assets","filter","asset","has","hash","map","fileHashes","path","join","ext","type","Boolean","flat","push"],"mappings":"AAAA;;;;+BAcgBA,oBAAkB;;aAAlBA,kBAAkB;;;8DAdjB,MAAM;;;;;;;;;;;AAchB,SAASA,kBAAkB,CAAC,EACjCC,OAAO,CAAA,EACPC,SAAS,CAAA,EACTC,eAAe,CAAA,EACfC,0BAA0B,CAAA,EAM3B,EAIC;IACA,sBAAsB;IACtB,OAAO;QACLC,OAAO,EAAE,CAAC;QACVC,OAAO,EAAE,OAAO;QAChBC,YAAY,EAAEC,MAAM,CAACC,OAAO,CAACR,OAAO,CAAC,CAACS,MAAM,CAC1C,CAACC,QAAQ,EAAE,CAACC,QAAQ,EAAEC,MAAM,CAAC,GAAK;YAChC,IAAID,QAAQ,KAAK,KAAK,EAAE,OAAOD,QAAQ,CAAC;YAExC,mEAAmE;YACnE,MAAMG,MAAM,GAAGD,MAAM,CAACC,MAAM,CACzBC,MAAM,CAAC,CAACC,KAAK,GAAK,CAACb,eAAe,IAAI,CAACA,eAAe,CAACc,GAAG,CAACD,KAAK,CAACE,IAAI,CAAC,CAAC,CACvEC,GAAG,CAAC,CAACH,KAAK;oBACT,oEAAoE;gBACpEA,GAAgB;gBAAhBA,OAAAA,CAAAA,GAAgB,GAAhBA,KAAK,CAACI,UAAU,SAAK,GAArBJ,KAAAA,CAAqB,GAArBA,GAAgB,CAAEG,GAAG,CAAC,CAACD,IAAI,GAAK,CAAC;wBAC/BG,IAAI,EAAEA,KAAI,EAAA,QAAA,CAACC,IAAI,CAAC,QAAQ,EAAEJ,IAAI,CAAC;wBAC/BK,GAAG,EAAEP,KAAK,CAACQ,IAAI;qBAChB,CAAC,CAAC,CAAA;aAAA,CACJ,CACAT,MAAM,CAACU,OAAO,CAAC,CACfC,IAAI,EAAE,AAAC;YAEV,IAAItB,CAAAA,0BAA0B,QAAY,GAAtCA,KAAAA,CAAsC,GAAtCA,0BAA0B,AAAE,CAACQ,QAAQ,CAAC,CAAA,IAAI,IAAI,EAAE;gBAClDE,MAAM,CAACa,IAAI,IAAIvB,0BAA0B,QAAY,GAAtCA,KAAAA,CAAsC,GAAtCA,0BAA0B,AAAE,CAACQ,QAAQ,CAAC,CAAC,CAAC;YACzD,CAAC;YAED,OAAO;gBACL,GAAGD,QAAQ;gBACX,CAACC,QAAQ,CAAC,EAAE;oBACV,+CAA+C;oBAC/C,iDAAiD;oBACjDC,MAAM,EAAEX,SAAS,CAACU,QAAQ,CAAC,CAAC,CAAC,CAAC;oBAC9BE,MAAM;iBACP;aACF,CAAC;QACJ,CAAC,EACD,EAAE,CACH;KACF,CAAC;AACJ,CAAC"}